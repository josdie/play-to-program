''' Simulated annealing algorithm for determining student model.
 
 
'''

import random
import math
import students

def most_likely_explanation(test_student, problem_set, student_answers, calculator):
    ''' Determines most likely competence set for a student
    
    Primes a competence vector for a test student and then runs simulated
    annealing on it.
    '''
    for concept in test_student.concepts:
        test_student.set_competence(concept, 0.5)
        
    simulated_annealing(test_student, problem_set, student_answers, calculator)
    
    return test_student.competences


def simulated_annealing(test_student, problem_set, student_answers, calculator):
    ''' Simulated annealing algorithm
    
    For detailed explanation see:
    http://en.wikipedia.org/wiki/Simulated_annealing
    '''
    # Initial state and entropy
    s = test_student.competences
    e = students.get_probability_of_outcome(problem_set, student_answers, test_student, calculator)
    
    s_best = {}
    for concept in s:
        s_best[concept] = s[concept]
    ebest = e
    
    k = 0
    kmax = 2000.0
    while k < kmax: #TODO change to analytical sentinel?
        temp = k / kmax
        s_new = gen_neighbor(s, temp)
        test_student.competences = s_new
        e_new = students.get_probability_of_outcome(problem_set, student_answers, test_student, calculator)
        if prob_move(e, e_new, temp) > random.random():
            s = s_new
            e = e_new
        if prob_move(e, e_new, temp) > random.random():
            s = s_new
        if e > ebest:
            s_best = {}
            for concept in s:
                s_best[concept] = s[concept]
            ebest = e_new
        k += 1
        
    test_student.competences = s_best


def gen_neighbor(comps, temperature):
    ''' Generates a semi-random neighbor state to the given competence vector
    
    Neighbor is generated by random perturbations of entries in the competence
    vector.
    '''
    neighbor = {}
    for concept in comps:
        move = random.randint(-1, 1)
        new_comp = min(1, max(0, comps[concept] + temperature * move))
        neighbor[concept] = new_comp
    return neighbor

   
def prob_move(e, e_new, t):
    ''' Returns the probability of changing states
    
    Probability is based on the relative change in 'energy' and the 
    'temperature' of the system.
    '''
    distance = math.fabs(e - e_new)
    if e_new > e:
        return .9
    else:
        return (1 - distance) * (1 - t) + (1 - t)
    
    
    
    
'''    
def update_model(stud, prob, answer, calculator):
    s = guess
    test_student.competences= mkdict(test_student.concepts, s)
    e = students.get_probability_of_outcome(problem_set, student_answers, test_student, calculator)
    sbest = []
    for item in s:
        sbest.append(item)
    ebest = e
    k = 0
    kmax = 2000.0
    while k < kmax:
        temp = k / kmax
        snew = gen_neighbor(s, temp)
        test_student.competences= mkdict(test_student.concepts, snew)
        enew = students.get_probability_of_outcome(problem_set, student_answers, test_student, calculator)
        
        if prob_move(e, enew, temp) > random.random():
            s = snew
            e = enew
        if e > ebest:
            sbest = []
            for item in s:
                sbest.append(item)
            ebest = enew
        k += 1

    return sbest

def gen_updating_neighbor(guess, problem, temperature):
    neighbor = []
    for competence in guess:
        move = random.randint(-1, 1)
        new_comp = min(1, max(0, competence + temperature * move))
        neighbor.append(new_comp)
    return neighbor
    '''